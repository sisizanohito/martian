package cli

import (
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"

	discord "github.com/bwmarrin/discordgo"
	"github.com/dustin/go-humanize"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	"gopkg.in/src-d/go-git.v4"
	"gopkg.in/src-d/go-git.v4/plumbing/object"
	"gopkg.in/src-d/go-git.v4/plumbing/storer"
)

var notifyCmd = &cobra.Command{
	Use: "notify",
	RunE: func(cmd *cobra.Command, args []string) error {
		return cmd.Usage()
	},
}

func getDiscord() (*discord.Session, error) {
	t := viper.GetString("discord.token")
	if len(t) == 0 {
		return nil, errors.New("no discord token provided")
	}
	s, err := discord.New("Bot " + t)
	if err != nil {
		return nil, err
	}
	return s, nil
}

const (
	colorGreen = 0x228B22
	colorRed   = 0xff2400
)

var notifyNewAssets = &cobra.Command{
	Use: "assets",
	RunE: func(cmd *cobra.Command, args []string) error {
		var (
			languages Languages
		)
		d, err := getDiscord()
		if err != nil {
			return err
		}
		if err = viper.UnmarshalKey("languages", &languages); err != nil {
			return err
		}
		verRaw, err := readFile("version.txt")
		if err != nil {
			return err
		}
		ver := strings.TrimSpace(string(verRaw))
		resourceRepo, err := git.PlainOpen(".")
		if err != nil {
			return err
		}
		if err != nil {
			return err
		}
		resRef, err := resourceRepo.Head()
		if err != nil {
			return err
		}
		resCommit, err := resourceRepo.CommitObject(resRef.Hash())
		if err != nil {
			return err
		}
		folders := make(map[string][]string)
		langChanged := make(map[Language]bool)
		if err = resCommit.Parents().ForEach(func(commit *object.Commit) error {
			patch, err := resCommit.Patch(commit)
			if err != nil {
				return err
			}
			for _, p := range patch.FilePatches() {
				from, to := p.Files()
				var searchIn []string
				if from != nil {
					searchIn = append(searchIn, from.Path())
				}
				if to != nil {
					searchIn = append(searchIn, to.Path())
				}
				for _, name := range searchIn {
					if strings.HasSuffix(name, ".xml") {
						dir := filepath.Dir(name)
						base := filepath.Base(name)
						folders[dir] = append(folders[dir], strings.TrimSuffix(base, ".xml"))

						for _, l := range languages {
							if strings.HasPrefix(base, l.GetPrefix()) {
								langChanged[l] = true
							}
						}
					}
					return nil
				}
			}
			return nil
		}); err != nil {
			return err
		}
		repo, err := git.PlainOpen("locales")
		if err != nil {
			return err
		}
		ref, err := repo.Head()
		if err != nil {
			return err
		}
		var latest time.Time
		iter, err := repo.Log(&git.LogOptions{
			From: ref.Hash(),
		})
		if err != nil {
			return err
		}
		if err = iter.ForEach(func(commit *object.Commit) error {
			if !strings.HasPrefix(commit.Message, "automated") {
				latest = commit.Author.When
				return storer.ErrStop
			}
			return nil
		}); err != nil {
			return err
		}
		commit, err := repo.CommitObject(ref.Hash())
		if err != nil {
			return err
		}
		f, err := os.Open("StreamingAssets.zip")
		if err != nil {
			return fmt.Errorf("failed to open StreamingAssets: %v", err)
		}
		defer f.Close()
		df := &discord.File{
			Name: fmt.Sprintf("StreamingAssets-R%s-L%s.zip",
				resRef.Hash().String()[:7],
				ref.Hash().String()[:7],
			),
			ContentType: "application/zip",
			Reader:      f,
		}
		description := new(strings.Builder)
		fmt.Fprintln(description, "The assets were automatically generated.")
		fmt.Fprint(description, "\n")
		if len(folders) == 0 {
			fmt.Fprintln(description, "**No xml files changed.**")
		} else {
			var foldersList []string
			for k := range folders {
				foldersList = append(foldersList, k)
			}
			sort.Strings(foldersList)
			fmt.Fprintln(description, "**Files changed:**")
			for _, folder := range foldersList {
				fmt.Fprintf(description, "[%s]: %d\n", folder, len(folders[folder]))
			}
			if len(langChanged) > 0 {
				var affected []string
				for _, l := range languages {
					if langChanged[l] {
						affected = append(affected, l.Name)
					}
				}
				sort.Strings(affected)
				fmt.Fprint(description, "\n")
				fmt.Fprintln(description, "**Languages affected:**", strings.Join(affected, ", "))
			}
		}
		fmt.Fprintf(description, "\nSee raw commit:\nhttps://github.com/sisizanohito/stationeers_resources/commit/%s", resRef.Hash().String()[:7])
		descriptionStr := description.String()
		if description.Len() > 2000 {
			descriptionStr = descriptionStr[:2000] + "..."
		}
		embed := &discord.MessageEmbed{
			Color:       colorGreen,
			Title:       "New assets",
			Description: descriptionStr,
			Footer: &discord.MessageEmbedFooter{
				Text: "Generated by Martian, the Great Localization Robot",
			},
		}
		embed.Fields = []*discord.MessageEmbedField{
			{
				Name:  "Version",
				Value: "v" + ver,
			},
			{
				Name:  "Locale commit",
				Value: commit.Message,
			},
			{
				Name:  "Locale latest update",
				Value: humanize.Time(latest),
			},
		}
		mes := &discord.MessageSend{
			Embed: embed,
			Files: []*discord.File{
				df,
			},
		}
		st, err := d.ChannelMessageSendComplex("888946186273325087", mes)
		if err != nil {
			return fmt.Errorf("failed to send message: %v", err)
		}
		fmt.Println("OK", st.ID)
		return nil
	},
}

var notifyErrCmd = &cobra.Command{
	Use:   "error",
	Short: "Notify about error",
	RunE: func(cmd *cobra.Command, args []string) error {
		sess, err := getDiscord()
		if err != nil {
			return err
		}
		embed := &discord.MessageEmbed{
			Color:       colorRed,
			Title:       viper.GetString("notification.title"),
			Description: viper.GetString("notification.text"),
			Footer: &discord.MessageEmbedFooter{
				Text: "Generated by Martian, the Great Localization Robot",
			},
		}
		embed.Fields = []*discord.MessageEmbedField{
			{
				Name:  "Task",
				Value: viper.GetString("notification.task"),
			},
		}
		mes := &discord.MessageSend{
			Embed: embed,
		}
		if _, err = sess.ChannelMessageSendComplex("888946186273325087", mes); err != nil {
			return fmt.Errorf("failed to send notification: %v", err)
		}
		return nil
	},
}

func init() {
	persistentFlags := notifyCmd.PersistentFlags()
	persistentFlags.String("token", "", "bot auth token")
	notifyCmd.AddCommand(
		notifyNewAssets,
		notifyErrCmd,
	)
	{
		f := notifyErrCmd.Flags()
		f.String("title", "Task failed", "Notification title")
		f.String("text", "Something went wrong", "Notification body")
		f.String("task", "task", "ID of task")

		viper.BindPFlag("notification.title", f.Lookup("title"))
		viper.BindPFlag("notification.text", f.Lookup("text"))
		viper.BindPFlag("notification.task", f.Lookup("task"))
	}
	rootCmd.AddCommand(
		notifyCmd,
	)
	viper.BindPFlag("discord.token", persistentFlags.Lookup("token"))
	viper.BindEnv("discord.token", "DISCORD_TOKEN")
}
